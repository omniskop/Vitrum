// Code generated by vitrum gencmd. DO NOT EDIT.

package pdf

import (
	"fmt"
	vit "github.com/omniskop/vitrum/vit"
	parse "github.com/omniskop/vitrum/vit/parse"
	std "github.com/omniskop/vitrum/vit/std"
)

func newFileContextForDocumentComponent(globalCtx *vit.GlobalContext) (*vit.FileContext, error) {
	fileCtx := vit.NewFileContext(globalCtx)

	var lib parse.Library
	var err error
	lib, err = parse.ResolveLibrary([]string{"Vit"})
	if err != nil {
		// The file used to generate the "DocumentComponent" component imported a library called "Vit".
		// If this error occurs that imported failed. Probably because the library is not known.
		return nil, fmt.Errorf("unable to create file context for generated \"DocumentComponent\" component: %w", err)
	}
	parse.AddLibraryToContainer(lib, &fileCtx.KnownComponents)

	return fileCtx, nil
}

type DocumentComponent struct {
	*std.Item
	id string

	format       vit.IntValue
	orientation  vit.IntValue
	childLayouts vit.LayoutList
}

// newDocumentComponentInGlobal creates an appropriate file context for the component and then returns a new DocumentComponent instance.
// The returned error will only be set if a library import that is required by the component fails.
func newDocumentComponentInGlobal(id string, globalCtx *vit.GlobalContext, thisLibrary parse.Library) (*DocumentComponent, error) {
	fileCtx, err := newFileContextForDocumentComponent(globalCtx)
	if err != nil {
		return nil, err
	}
	parse.AddLibraryToContainer(thisLibrary, &fileCtx.KnownComponents)
	return NewDocumentComponent(id, fileCtx), nil
}
func NewDocumentComponent(id string, context *vit.FileContext) *DocumentComponent {
	d := &DocumentComponent{
		Item:         std.NewItem("", context),
		id:           id,
		format:       *vit.NewIntValueFromCode(vit.Code{FileCtx: context, Code: "Page.A4", Position: nil}),
		orientation:  *vit.NewIntValueFromCode(vit.Code{FileCtx: context, Code: "Page.Portrait", Position: nil}),
		childLayouts: make(vit.LayoutList),
	}
	// property assignments on embedded components
	// register listeners for when a property changes
	d.format.AddDependent(vit.FuncDep(d.recalculateLayout))
	d.orientation.AddDependent(vit.FuncDep(d.recalculateLayout))
	// register event listeners
	// register enumerations
	// add child components

	context.RegisterComponent("", d)

	return d
}

func (d *DocumentComponent) String() string {
	return fmt.Sprintf("DocumentComponent(%s)", d.id)
}

func (d *DocumentComponent) Property(key string) (vit.Value, bool) {
	switch key {
	case "format":
		return &d.format, true
	case "orientation":
		return &d.orientation, true
	default:
		return d.Item.Property(key)
	}
}

func (d *DocumentComponent) MustProperty(key string) vit.Value {
	v, ok := d.Property(key)
	if !ok {
		panic(fmt.Errorf("MustProperty called with unknown key %q", key))
	}
	return v
}

func (d *DocumentComponent) SetProperty(key string, value interface{}) error {
	var err error
	switch key {
	case "format":
		err = d.format.SetValue(value)
	case "orientation":
		err = d.orientation.SetValue(value)
	default:
		return d.Item.SetProperty(key, value)
	}
	if err != nil {
		return vit.NewPropertyError("DocumentComponent", key, d.id, err)
	}
	return nil
}

func (d *DocumentComponent) SetPropertyCode(key string, code vit.Code) error {
	switch key {
	case "format":
		d.format.SetCode(code)
	case "orientation":
		d.orientation.SetCode(code)
	default:
		return d.Item.SetPropertyCode(key, code)
	}
	return nil
}

func (d *DocumentComponent) Event(name string) (vit.Listenable, bool) {
	switch name {
	default:
		return d.Item.Event(name)
	}
}

func (d *DocumentComponent) ResolveVariable(key string) (interface{}, bool) {
	switch key {
	case "format":
		return &d.format, true
	case "orientation":
		return &d.orientation, true
	default:
		return d.Item.ResolveVariable(key)
	}
}

func (d *DocumentComponent) AddChild(child vit.Component) {
	defer d.childWasAdded(child)
	child.SetParent(d)
	d.AddChildButKeepParent(child)
}

func (d *DocumentComponent) AddChildAfter(afterThis vit.Component, addThis vit.Component) {
	defer d.childWasAdded(addThis)
	var targetType vit.Component = afterThis

	for ind, child := range d.Children() {
		if child.As(&targetType) {
			addThis.SetParent(d)
			d.AddChildAtButKeepParent(addThis, ind+1)
			return
		}
	}
	d.AddChild(addThis)
}

func (d *DocumentComponent) UpdateExpressions(context vit.Component) (int, vit.ErrorGroup) {
	var sum int
	var errs vit.ErrorGroup

	if context == nil {
		context = d
	}
	// properties
	if changed, err := d.format.Update(context); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("DocumentComponent", "format", d.id, err))
		}
	}
	if changed, err := d.orientation.Update(context); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("DocumentComponent", "orientation", d.id, err))
		}
	}

	// methods

	n, err := d.Item.UpdateExpressions(context)
	sum += n
	errs.AddGroup(err)
	return sum, errs
}

func (d *DocumentComponent) As(target *vit.Component) bool {
	if _, ok := (*target).(*DocumentComponent); ok {
		*target = d
		return true
	}
	return d.Item.As(target)
}

func (d *DocumentComponent) ID() string {
	return d.id
}

func (d *DocumentComponent) Finish() error {
	return d.RootC().FinishInContext(d)
}

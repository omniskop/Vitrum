// Code generated by vitrum gencmd. DO NOT EDIT.

package std

import (
	"fmt"
	vit "github.com/omniskop/vitrum/vit"
)

func newFileContextForGrid(globalCtx *vit.GlobalContext) (*vit.FileContext, error) {
	return vit.NewFileContext(globalCtx), nil
}

type Grid_HorizontalItemAlignment uint

const (
	Grid_HorizontalItemAlignment_AlignLeft    Grid_HorizontalItemAlignment = 0
	Grid_HorizontalItemAlignment_AlignHCenter Grid_HorizontalItemAlignment = 1
	Grid_HorizontalItemAlignment_AlignRight   Grid_HorizontalItemAlignment = 2
)

func (enum Grid_HorizontalItemAlignment) String() string {
	switch enum {
	case Grid_HorizontalItemAlignment_AlignLeft:
		return "AlignLeft"
	case Grid_HorizontalItemAlignment_AlignHCenter:
		return "AlignHCenter"
	case Grid_HorizontalItemAlignment_AlignRight:
		return "AlignRight"
	default:
		return "<unknownHorizontalItemAlignment>"
	}
}

type Grid_VerticalItemAlignment uint

const (
	Grid_VerticalItemAlignment_AlignTop     Grid_VerticalItemAlignment = 0
	Grid_VerticalItemAlignment_AlignVCenter Grid_VerticalItemAlignment = 1
	Grid_VerticalItemAlignment_AlignBottom  Grid_VerticalItemAlignment = 2
)

func (enum Grid_VerticalItemAlignment) String() string {
	switch enum {
	case Grid_VerticalItemAlignment_AlignTop:
		return "AlignTop"
	case Grid_VerticalItemAlignment_AlignVCenter:
		return "AlignVCenter"
	case Grid_VerticalItemAlignment_AlignBottom:
		return "AlignBottom"
	default:
		return "<unknownVerticalItemAlignment>"
	}
}

type Grid_Flow uint

const (
	Grid_Flow_LeftToRight Grid_Flow = 0
	Grid_Flow_TopToBottom Grid_Flow = 1
)

func (enum Grid_Flow) String() string {
	switch enum {
	case Grid_Flow_LeftToRight:
		return "LeftToRight"
	case Grid_Flow_TopToBottom:
		return "TopToBottom"
	default:
		return "<unknownFlow>"
	}
}

type Grid struct {
	*Item
	id string

	topPadding              vit.OptionalValue[*vit.FloatValue]
	rightPadding            vit.OptionalValue[*vit.FloatValue]
	bottomPadding           vit.OptionalValue[*vit.FloatValue]
	leftPadding             vit.OptionalValue[*vit.FloatValue]
	padding                 vit.FloatValue
	spacing                 vit.FloatValue
	columnSpacing           vit.OptionalValue[*vit.FloatValue]
	rowSpacing              vit.OptionalValue[*vit.FloatValue]
	columns                 vit.OptionalValue[*vit.IntValue]
	rows                    vit.OptionalValue[*vit.IntValue]
	horizontalItemAlignment vit.IntValue
	verticalItemAlignment   vit.IntValue
	flow                    vit.IntValue
	childLayouts            vit.LayoutList
}

// newGridInGlobal creates an appropriate file context for the component and then returns a new Grid instance.
// The returned error will only be set if a library import that is required by the component fails.
func newGridInGlobal(id string, globalCtx *vit.GlobalContext) (*Grid, error) {
	fileCtx, err := newFileContextForGrid(globalCtx)
	if err != nil {
		return nil, err
	}
	return NewGrid(id, fileCtx), nil
}
func NewGrid(id string, context *vit.FileContext) *Grid {
	g := &Grid{
		Item:                    NewItem("", context),
		id:                      id,
		topPadding:              *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		rightPadding:            *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		bottomPadding:           *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		leftPadding:             *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		padding:                 *vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil}),
		spacing:                 *vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil}),
		columnSpacing:           *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		rowSpacing:              *vit.NewOptionalValue(vit.NewFloatValueFromCode(vit.Code{FileCtx: context, Code: "0", Position: nil})),
		columns:                 *vit.NewOptionalValue(vit.NewEmptyIntValue()),
		rows:                    *vit.NewOptionalValue(vit.NewEmptyIntValue()),
		horizontalItemAlignment: *vit.NewIntValueFromCode(vit.Code{FileCtx: context, Code: "HorizontalItemAlignment.AlignLeft", Position: nil}),
		verticalItemAlignment:   *vit.NewIntValueFromCode(vit.Code{FileCtx: context, Code: "VerticalItemAlignment.AlignTop", Position: nil}),
		flow:                    *vit.NewIntValueFromCode(vit.Code{FileCtx: context, Code: "Flow.LeftToRight", Position: nil}),
		childLayouts:            make(vit.LayoutList),
	}
	// property assignments on embedded components
	// register listeners for when a property changes
	g.topPadding.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.rightPadding.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.bottomPadding.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.leftPadding.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.padding.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.spacing.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.columnSpacing.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.rowSpacing.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.columns.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.rows.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.horizontalItemAlignment.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.verticalItemAlignment.AddDependent(vit.FuncDep(g.recalculateLayout))
	g.flow.AddDependent(vit.FuncDep(g.recalculateLayout))
	// register event listeners
	// register enumerations
	g.DefineEnum(vit.Enumeration{
		Embedded: true,
		Name:     "HorizontalItemAlignment",
		Position: nil,
		Values:   map[string]int{"AlignLeft": 0, "AlignHCenter": 1, "AlignRight": 2},
	})
	g.DefineEnum(vit.Enumeration{
		Embedded: true,
		Name:     "VerticalItemAlignment",
		Position: nil,
		Values:   map[string]int{"AlignTop": 0, "AlignVCenter": 1, "AlignBottom": 2},
	})
	g.DefineEnum(vit.Enumeration{
		Embedded: true,
		Name:     "Flow",
		Position: nil,
		Values:   map[string]int{"LeftToRight": 0, "TopToBottom": 1},
	})
	// add child components

	context.RegisterComponent("", g)

	return g
}

func (g *Grid) String() string {
	return fmt.Sprintf("Grid(%s)", g.id)
}

func (g *Grid) Property(key string) (vit.Value, bool) {
	switch key {
	case "topPadding":
		return &g.topPadding, true
	case "rightPadding":
		return &g.rightPadding, true
	case "bottomPadding":
		return &g.bottomPadding, true
	case "leftPadding":
		return &g.leftPadding, true
	case "padding":
		return &g.padding, true
	case "spacing":
		return &g.spacing, true
	case "columnSpacing":
		return &g.columnSpacing, true
	case "rowSpacing":
		return &g.rowSpacing, true
	case "columns":
		return &g.columns, true
	case "rows":
		return &g.rows, true
	case "horizontalItemAlignment":
		return &g.horizontalItemAlignment, true
	case "verticalItemAlignment":
		return &g.verticalItemAlignment, true
	case "flow":
		return &g.flow, true
	default:
		return g.Item.Property(key)
	}
}

func (g *Grid) MustProperty(key string) vit.Value {
	v, ok := g.Property(key)
	if !ok {
		panic(fmt.Errorf("MustProperty called with unknown key %q", key))
	}
	return v
}

func (g *Grid) SetProperty(key string, value interface{}) error {
	var err error
	switch key {
	case "topPadding":
		err = g.topPadding.SetValue(value)
	case "rightPadding":
		err = g.rightPadding.SetValue(value)
	case "bottomPadding":
		err = g.bottomPadding.SetValue(value)
	case "leftPadding":
		err = g.leftPadding.SetValue(value)
	case "padding":
		err = g.padding.SetValue(value)
	case "spacing":
		err = g.spacing.SetValue(value)
	case "columnSpacing":
		err = g.columnSpacing.SetValue(value)
	case "rowSpacing":
		err = g.rowSpacing.SetValue(value)
	case "columns":
		err = g.columns.SetValue(value)
	case "rows":
		err = g.rows.SetValue(value)
	case "horizontalItemAlignment":
		err = g.horizontalItemAlignment.SetValue(value)
	case "verticalItemAlignment":
		err = g.verticalItemAlignment.SetValue(value)
	case "flow":
		err = g.flow.SetValue(value)
	default:
		return g.Item.SetProperty(key, value)
	}
	if err != nil {
		return vit.NewPropertyError("Grid", key, g.id, err)
	}
	return nil
}

func (g *Grid) SetPropertyCode(key string, code vit.Code) error {
	switch key {
	case "topPadding":
		g.topPadding.SetCode(code)
	case "rightPadding":
		g.rightPadding.SetCode(code)
	case "bottomPadding":
		g.bottomPadding.SetCode(code)
	case "leftPadding":
		g.leftPadding.SetCode(code)
	case "padding":
		g.padding.SetCode(code)
	case "spacing":
		g.spacing.SetCode(code)
	case "columnSpacing":
		g.columnSpacing.SetCode(code)
	case "rowSpacing":
		g.rowSpacing.SetCode(code)
	case "columns":
		g.columns.SetCode(code)
	case "rows":
		g.rows.SetCode(code)
	case "horizontalItemAlignment":
		g.horizontalItemAlignment.SetCode(code)
	case "verticalItemAlignment":
		g.verticalItemAlignment.SetCode(code)
	case "flow":
		g.flow.SetCode(code)
	default:
		return g.Item.SetPropertyCode(key, code)
	}
	return nil
}

func (g *Grid) Event(name string) (vit.Listenable, bool) {
	switch name {
	default:
		return g.Item.Event(name)
	}
}

func (g *Grid) ResolveVariable(key string) (interface{}, bool) {
	switch key {
	case "topPadding":
		return &g.topPadding, true
	case "rightPadding":
		return &g.rightPadding, true
	case "bottomPadding":
		return &g.bottomPadding, true
	case "leftPadding":
		return &g.leftPadding, true
	case "padding":
		return &g.padding, true
	case "spacing":
		return &g.spacing, true
	case "columnSpacing":
		return &g.columnSpacing, true
	case "rowSpacing":
		return &g.rowSpacing, true
	case "columns":
		return &g.columns, true
	case "rows":
		return &g.rows, true
	case "horizontalItemAlignment":
		return &g.horizontalItemAlignment, true
	case "verticalItemAlignment":
		return &g.verticalItemAlignment, true
	case "flow":
		return &g.flow, true
	default:
		return g.Item.ResolveVariable(key)
	}
}

func (g *Grid) AddChild(child vit.Component) {
	defer g.childWasAdded(child)
	child.SetParent(g)
	g.AddChildButKeepParent(child)
}

func (g *Grid) AddChildAfter(afterThis vit.Component, addThis vit.Component) {
	defer g.childWasAdded(addThis)
	var targetType vit.Component = afterThis

	for ind, child := range g.Children() {
		if child.As(&targetType) {
			addThis.SetParent(g)
			g.AddChildAtButKeepParent(addThis, ind+1)
			return
		}
	}
	g.AddChild(addThis)
}

func (g *Grid) UpdateExpressions() (int, vit.ErrorGroup) {
	var sum int
	var errs vit.ErrorGroup

	// properties
	if changed, err := g.topPadding.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "topPadding", g.id, err))
		}
	}
	if changed, err := g.rightPadding.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "rightPadding", g.id, err))
		}
	}
	if changed, err := g.bottomPadding.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "bottomPadding", g.id, err))
		}
	}
	if changed, err := g.leftPadding.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "leftPadding", g.id, err))
		}
	}
	if changed, err := g.padding.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "padding", g.id, err))
		}
	}
	if changed, err := g.spacing.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "spacing", g.id, err))
		}
	}
	if changed, err := g.columnSpacing.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "columnSpacing", g.id, err))
		}
	}
	if changed, err := g.rowSpacing.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "rowSpacing", g.id, err))
		}
	}
	if changed, err := g.columns.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "columns", g.id, err))
		}
	}
	if changed, err := g.rows.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "rows", g.id, err))
		}
	}
	if changed, err := g.horizontalItemAlignment.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "horizontalItemAlignment", g.id, err))
		}
	}
	if changed, err := g.verticalItemAlignment.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "verticalItemAlignment", g.id, err))
		}
	}
	if changed, err := g.flow.Update(g); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Grid", "flow", g.id, err))
		}
	}

	// methods

	// this needs to be done in every component and not just in root to give the expression the highest level component for resolving variables
	n, err := g.UpdatePropertiesInContext(g)
	sum += n
	errs.AddGroup(err)
	n, err = g.Item.UpdateExpressions()
	sum += n
	errs.AddGroup(err)
	return sum, errs
}

func (g *Grid) As(target *vit.Component) bool {
	if _, ok := (*target).(*Grid); ok {
		*target = g
		return true
	}
	return g.Item.As(target)
}

func (g *Grid) ID() string {
	return g.id
}

func (g *Grid) Finish() error {
	return g.RootC().FinishInContext(g)
}

func (g *Grid) staticAttribute(name string) (interface{}, bool) {
	switch name {
	case "AlignLeft":
		return uint(Grid_HorizontalItemAlignment_AlignLeft), true
	case "AlignHCenter":
		return uint(Grid_HorizontalItemAlignment_AlignHCenter), true
	case "AlignRight":
		return uint(Grid_HorizontalItemAlignment_AlignRight), true
	case "AlignTop":
		return uint(Grid_VerticalItemAlignment_AlignTop), true
	case "AlignVCenter":
		return uint(Grid_VerticalItemAlignment_AlignVCenter), true
	case "AlignBottom":
		return uint(Grid_VerticalItemAlignment_AlignBottom), true
	case "LeftToRight":
		return uint(Grid_Flow_LeftToRight), true
	case "TopToBottom":
		return uint(Grid_Flow_TopToBottom), true
	default:
		return nil, false
	}
}

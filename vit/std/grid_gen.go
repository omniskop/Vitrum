// Code generated by vitrum gencmd. DO NOT EDIT.

package std

import (
	"fmt"
	vit "github.com/omniskop/vitrum/vit"
)

type Grid_HorizontalItemAlignment uint

const (
	Grid_HorizontalItemAlignment_AlignLeft    Grid_HorizontalItemAlignment = 0
	Grid_HorizontalItemAlignment_AlignHCenter Grid_HorizontalItemAlignment = 1
	Grid_HorizontalItemAlignment_AlignRight   Grid_HorizontalItemAlignment = 2
)

type Grid_VerticalItemAlignment uint

const (
	Grid_VerticalItemAlignment_AlignTop     Grid_VerticalItemAlignment = 0
	Grid_VerticalItemAlignment_AlignVCenter Grid_VerticalItemAlignment = 1
	Grid_VerticalItemAlignment_AlignBottom  Grid_VerticalItemAlignment = 2
)

type Grid_Flow uint

const (
	Grid_Flow_LeftToRight Grid_Flow = 0
	Grid_Flow_TopToBottom Grid_Flow = 1
)

type Grid struct {
	Item
	id string

	topPadding              vit.OptionalValue[*vit.FloatValue]
	rightPadding            vit.OptionalValue[*vit.FloatValue]
	bottomPadding           vit.OptionalValue[*vit.FloatValue]
	leftPadding             vit.OptionalValue[*vit.FloatValue]
	padding                 vit.FloatValue
	spacing                 vit.FloatValue
	columnSpacing           vit.OptionalValue[*vit.FloatValue]
	rowSpacing              vit.OptionalValue[*vit.FloatValue]
	columns                 vit.OptionalValue[*vit.IntValue]
	rows                    vit.OptionalValue[*vit.IntValue]
	horizontalItemAlignment vit.IntValue
	verticalItemAlignment   vit.IntValue
	flow                    vit.IntValue
	childLayouts            vit.LayoutList
}

func NewGrid(id string, scope vit.ComponentContainer) *Grid {
	return &Grid{
		Item:                    *NewItem(id, scope),
		id:                      id,
		topPadding:              *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		rightPadding:            *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		bottomPadding:           *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		leftPadding:             *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		padding:                 *vit.NewFloatValue("", nil),
		spacing:                 *vit.NewFloatValue("", nil),
		columnSpacing:           *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		rowSpacing:              *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		columns:                 *vit.NewOptionalValue(vit.NewIntValue("", nil)),
		rows:                    *vit.NewOptionalValue(vit.NewIntValue("", nil)),
		horizontalItemAlignment: *vit.NewIntValue("", nil),
		verticalItemAlignment:   *vit.NewIntValue("", nil),
		flow:                    *vit.NewIntValue("", nil),
		childLayouts:            make(vit.LayoutList),
	}
}

func (g *Grid) String() string {
	return fmt.Sprintf("Grid(%s)", g.id)
}

func (g *Grid) Property(key string) (vit.Value, bool) {
	switch key {
	case "topPadding":
		return &g.topPadding, true
	case "rightPadding":
		return &g.rightPadding, true
	case "bottomPadding":
		return &g.bottomPadding, true
	case "leftPadding":
		return &g.leftPadding, true
	case "padding":
		return &g.padding, true
	case "spacing":
		return &g.spacing, true
	case "columnSpacing":
		return &g.columnSpacing, true
	case "rowSpacing":
		return &g.rowSpacing, true
	case "columns":
		return &g.columns, true
	case "rows":
		return &g.rows, true
	case "horizontalItemAlignment":
		return &g.horizontalItemAlignment, true
	case "verticalItemAlignment":
		return &g.verticalItemAlignment, true
	case "flow":
		return &g.flow, true
	default:
		return g.Item.Property(key)
	}
}

func (g *Grid) MustProperty(key string) vit.Value {
	v, ok := g.Property(key)
	if !ok {
		panic(fmt.Errorf("MustProperty called with unknown key %q", key))
	}
	return v
}

func (g *Grid) SetProperty(key string, value interface{}, position *vit.PositionRange) bool {
	switch key {
	case "topPadding":
		g.topPadding.ChangeCode(value.(string), position)
	case "rightPadding":
		g.rightPadding.ChangeCode(value.(string), position)
	case "bottomPadding":
		g.bottomPadding.ChangeCode(value.(string), position)
	case "leftPadding":
		g.leftPadding.ChangeCode(value.(string), position)
	case "padding":
		g.padding.ChangeCode(value.(string), position)
	case "spacing":
		g.spacing.ChangeCode(value.(string), position)
	case "columnSpacing":
		g.columnSpacing.ChangeCode(value.(string), position)
	case "rowSpacing":
		g.rowSpacing.ChangeCode(value.(string), position)
	case "columns":
		g.columns.ChangeCode(value.(string), position)
	case "rows":
		g.rows.ChangeCode(value.(string), position)
	case "horizontalItemAlignment":
		g.horizontalItemAlignment.ChangeCode(value.(string), position)
	case "verticalItemAlignment":
		g.verticalItemAlignment.ChangeCode(value.(string), position)
	case "flow":
		g.flow.ChangeCode(value.(string), position)
	default:
		return g.Item.SetProperty(key, value, position)
	}
	return true
}

func (g *Grid) ResolveVariable(key string) (interface{}, bool) {
	switch key {
	case g.id:
		return g, true
	case "topPadding":
		return &g.topPadding, true
	case "rightPadding":
		return &g.rightPadding, true
	case "bottomPadding":
		return &g.bottomPadding, true
	case "leftPadding":
		return &g.leftPadding, true
	case "padding":
		return &g.padding, true
	case "spacing":
		return &g.spacing, true
	case "columnSpacing":
		return &g.columnSpacing, true
	case "rowSpacing":
		return &g.rowSpacing, true
	case "columns":
		return &g.columns, true
	case "rows":
		return &g.rows, true
	case "horizontalItemAlignment":
		return &g.horizontalItemAlignment, true
	case "verticalItemAlignment":
		return &g.verticalItemAlignment, true
	case "flow":
		return &g.flow, true
	default:
		return g.Item.ResolveVariable(key)
	}
}

func (g *Grid) AddChild(child vit.Component) {
	defer g.childWasAdded(child)
	child.SetParent(g)
	g.AddChildButKeepParent(child)
}

func (g *Grid) AddChildAfter(afterThis vit.Component, addThis vit.Component) {
	defer g.childWasAdded(addThis)
	var targetType vit.Component = afterThis

	for ind, child := range g.Children() {
		if child.As(&targetType) {
			addThis.SetParent(g)
			g.AddChildAtButKeepParent(addThis, ind+1)
			return
		}
	}
	g.AddChild(addThis)
}

func (g *Grid) UpdateExpressions() (int, vit.ErrorGroup) {
	var sum int
	var errs vit.ErrorGroup

	if g.topPadding.ShouldEvaluate() {
		sum++
		err := g.topPadding.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "topPadding", g.id, *g.topPadding.GetExpression(), err))
		}
		g.recalculateLayout(g.topPadding)
	}
	if g.rightPadding.ShouldEvaluate() {
		sum++
		err := g.rightPadding.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "rightPadding", g.id, *g.rightPadding.GetExpression(), err))
		}
		g.recalculateLayout(g.rightPadding)
	}
	if g.bottomPadding.ShouldEvaluate() {
		sum++
		err := g.bottomPadding.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "bottomPadding", g.id, *g.bottomPadding.GetExpression(), err))
		}
		g.recalculateLayout(g.bottomPadding)
	}
	if g.leftPadding.ShouldEvaluate() {
		sum++
		err := g.leftPadding.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "leftPadding", g.id, *g.leftPadding.GetExpression(), err))
		}
		g.recalculateLayout(g.leftPadding)
	}
	if g.padding.ShouldEvaluate() {
		sum++
		err := g.padding.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "padding", g.id, *g.padding.GetExpression(), err))
		}
		g.recalculateLayout(g.padding)
	}
	if g.spacing.ShouldEvaluate() {
		sum++
		err := g.spacing.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "spacing", g.id, *g.spacing.GetExpression(), err))
		}
		g.recalculateLayout(g.spacing)
	}
	if g.columnSpacing.ShouldEvaluate() {
		sum++
		err := g.columnSpacing.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "columnSpacing", g.id, *g.columnSpacing.GetExpression(), err))
		}
		g.recalculateLayout(g.columnSpacing)
	}
	if g.rowSpacing.ShouldEvaluate() {
		sum++
		err := g.rowSpacing.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "rowSpacing", g.id, *g.rowSpacing.GetExpression(), err))
		}
		g.recalculateLayout(g.rowSpacing)
	}
	if g.columns.ShouldEvaluate() {
		sum++
		err := g.columns.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "columns", g.id, *g.columns.GetExpression(), err))
		}
		g.recalculateLayout(g.columns)
	}
	if g.rows.ShouldEvaluate() {
		sum++
		err := g.rows.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "rows", g.id, *g.rows.GetExpression(), err))
		}
		g.recalculateLayout(g.rows)
	}
	if g.horizontalItemAlignment.ShouldEvaluate() {
		sum++
		err := g.horizontalItemAlignment.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "horizontalItemAlignment", g.id, *g.horizontalItemAlignment.GetExpression(), err))
		}
		g.recalculateLayout(g.horizontalItemAlignment)
	}
	if g.verticalItemAlignment.ShouldEvaluate() {
		sum++
		err := g.verticalItemAlignment.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "verticalItemAlignment", g.id, *g.verticalItemAlignment.GetExpression(), err))
		}
		g.recalculateLayout(g.verticalItemAlignment)
	}
	if g.flow.ShouldEvaluate() {
		sum++
		err := g.flow.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "flow", g.id, *g.flow.GetExpression(), err))
		}
		g.recalculateLayout(g.flow)
	}
	if g.childLayouts.ShouldEvaluate() {
		sum++
		err := g.childLayouts.Update(g)
		if err != nil {
			errs.Add(vit.NewExpressionError("Grid", "childLayouts", g.id, *g.childLayouts.GetExpression(), err))
		}
		g.recalculateLayout(g.childLayouts)
	}

	// this needs to be done in every component and not just in root to give the expression the highest level component for resolving variables
	n, err := g.UpdatePropertiesInContext(g)
	sum += n
	errs.AddGroup(err)
	n, err = g.Item.UpdateExpressions()
	sum += n
	errs.AddGroup(err)
	return sum, errs
}

func (g *Grid) As(target *vit.Component) bool {
	if _, ok := (*target).(*Grid); ok {
		*target = g
		return true
	}
	return g.Item.As(target)
}

func (g *Grid) ID() string {
	return g.id
}

func (g *Grid) Finish() error {
	return g.RootC().FinishInContext(g)
}

func (g *Grid) staticAttribute(name string) (interface{}, bool) {
	switch name {
	case "AlignLeft":
		return uint(Grid_HorizontalItemAlignment_AlignLeft), true
	case "AlignHCenter":
		return uint(Grid_HorizontalItemAlignment_AlignHCenter), true
	case "AlignRight":
		return uint(Grid_HorizontalItemAlignment_AlignRight), true
	case "AlignTop":
		return uint(Grid_VerticalItemAlignment_AlignTop), true
	case "AlignVCenter":
		return uint(Grid_VerticalItemAlignment_AlignVCenter), true
	case "AlignBottom":
		return uint(Grid_VerticalItemAlignment_AlignBottom), true
	case "LeftToRight":
		return uint(Grid_Flow_LeftToRight), true
	case "TopToBottom":
		return uint(Grid_Flow_TopToBottom), true
	default:
		return nil, false
	}
}

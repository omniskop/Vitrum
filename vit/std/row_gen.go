// Code generated by vitrum gencmd. DO NOT EDIT.

package std

import (
	"fmt"
	vit "github.com/omniskop/vitrum/vit"
)

type Row struct {
	Item
	id string

	topPadding    vit.OptionalValue[*vit.FloatValue]
	rightPadding  vit.OptionalValue[*vit.FloatValue]
	bottomPadding vit.OptionalValue[*vit.FloatValue]
	leftPadding   vit.OptionalValue[*vit.FloatValue]
	padding       vit.FloatValue
	spacing       vit.FloatValue
	childLayouts  layoutList
}

func NewRow(id string, scope vit.ComponentContainer) *Row {
	return &Row{
		Item:          *NewItem(id, scope),
		id:            id,
		topPadding:    *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		rightPadding:  *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		bottomPadding: *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		leftPadding:   *vit.NewOptionalValue(vit.NewFloatValue("", nil)),
		padding:       *vit.NewFloatValue("", nil),
		spacing:       *vit.NewFloatValue("", nil),
		childLayouts:  make(layoutList),
	}
}

func (r *Row) String() string {
	return fmt.Sprintf("Row(%s)", r.id)
}

func (r *Row) Property(key string) (vit.Value, bool) {
	switch key {
	case "topPadding":
		return &r.topPadding, true
	case "rightPadding":
		return &r.rightPadding, true
	case "bottomPadding":
		return &r.bottomPadding, true
	case "leftPadding":
		return &r.leftPadding, true
	case "padding":
		return &r.padding, true
	case "spacing":
		return &r.spacing, true
	default:
		return r.Item.Property(key)
	}
}

func (r *Row) MustProperty(key string) vit.Value {
	v, ok := r.Property(key)
	if !ok {
		panic(fmt.Errorf("MustProperty called with unknown key %q", key))
	}
	return v
}

func (r *Row) SetProperty(key string, value interface{}, position *vit.PositionRange) bool {
	switch key {
	case "topPadding":
		r.topPadding.ChangeCode(value.(string), position)
	case "rightPadding":
		r.rightPadding.ChangeCode(value.(string), position)
	case "bottomPadding":
		r.bottomPadding.ChangeCode(value.(string), position)
	case "leftPadding":
		r.leftPadding.ChangeCode(value.(string), position)
	case "padding":
		r.padding.ChangeCode(value.(string), position)
	case "spacing":
		r.spacing.ChangeCode(value.(string), position)
	default:
		return r.Item.SetProperty(key, value, position)
	}
	return true
}

func (r *Row) ResolveVariable(key string) (interface{}, bool) {
	switch key {
	case r.id:
		return r, true
	case "topPadding":
		return &r.topPadding, true
	case "rightPadding":
		return &r.rightPadding, true
	case "bottomPadding":
		return &r.bottomPadding, true
	case "leftPadding":
		return &r.leftPadding, true
	case "padding":
		return &r.padding, true
	case "spacing":
		return &r.spacing, true
	default:
		return r.Item.ResolveVariable(key)
	}
}

func (r *Row) AddChild(child vit.Component) {
	defer r.childWasAdded(child)
	child.SetParent(r)
	r.AddChildButKeepParent(child)
}

func (r *Row) AddChildAfter(afterThis vit.Component, addThis vit.Component) {
	defer r.childWasAdded(addThis)
	var targetType vit.Component = afterThis

	for ind, child := range r.Children() {
		if child.As(&targetType) {
			addThis.SetParent(r)
			r.AddChildAtButKeepParent(addThis, ind+1)
			return
		}
	}
	r.AddChild(addThis)
}

func (r *Row) UpdateExpressions() (int, vit.ErrorGroup) {
	var sum int
	var errs vit.ErrorGroup

	if r.topPadding.ShouldEvaluate() {
		sum++
		err := r.topPadding.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "topPadding", r.id, *r.topPadding.GetExpression(), err))
		}
		r.recalculateLayout(r.topPadding)
	}
	if r.rightPadding.ShouldEvaluate() {
		sum++
		err := r.rightPadding.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "rightPadding", r.id, *r.rightPadding.GetExpression(), err))
		}
		r.recalculateLayout(r.rightPadding)
	}
	if r.bottomPadding.ShouldEvaluate() {
		sum++
		err := r.bottomPadding.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "bottomPadding", r.id, *r.bottomPadding.GetExpression(), err))
		}
		r.recalculateLayout(r.bottomPadding)
	}
	if r.leftPadding.ShouldEvaluate() {
		sum++
		err := r.leftPadding.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "leftPadding", r.id, *r.leftPadding.GetExpression(), err))
		}
		r.recalculateLayout(r.leftPadding)
	}
	if r.padding.ShouldEvaluate() {
		sum++
		err := r.padding.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "padding", r.id, *r.padding.GetExpression(), err))
		}
		r.recalculateLayout(r.padding)
	}
	if r.spacing.ShouldEvaluate() {
		sum++
		err := r.spacing.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "spacing", r.id, *r.spacing.GetExpression(), err))
		}
		r.recalculateLayout(r.spacing)
	}
	if r.childLayouts.ShouldEvaluate() {
		sum++
		err := r.childLayouts.Update(r)
		if err != nil {
			errs.Add(vit.NewExpressionError("Row", "childLayouts", r.id, *r.childLayouts.GetExpression(), err))
		}
		r.recalculateLayout(r.childLayouts)
	}

	// this needs to be done in every component and not just in root to give the expression the highest level component for resolving variables
	n, err := r.UpdatePropertiesInContext(r)
	sum += n
	errs.AddGroup(err)
	n, err = r.Item.UpdateExpressions()
	sum += n
	errs.AddGroup(err)
	return sum, errs
}

func (r *Row) As(target *vit.Component) bool {
	if _, ok := (*target).(*Row); ok {
		*target = r
		return true
	}
	return r.Item.As(target)
}

func (r *Row) ID() string {
	return r.id
}

func (r *Row) Finish() error {
	return r.RootC().FinishInContext(r)
}

// Code generated by vitrum gencmd. DO NOT EDIT.

package gui

import (
	"fmt"
	vit "github.com/omniskop/vitrum/vit"
	std "github.com/omniskop/vitrum/vit/std"
)

type Window struct {
	*std.Item
	id string

	title     vit.StringValue
	maxWidth  vit.FloatValue
	maxHeight vit.FloatValue
	minWidth  vit.FloatValue
	minHeight vit.FloatValue
}

func NewWindow(id string, scope vit.ComponentContainer) *Window {
	w := &Window{
		Item:      std.NewItem(id, scope),
		id:        id,
		title:     *vit.NewEmptyStringValue(),
		maxWidth:  *vit.NewEmptyFloatValue(),
		maxHeight: *vit.NewEmptyFloatValue(),
		minWidth:  *vit.NewEmptyFloatValue(),
		minHeight: *vit.NewEmptyFloatValue(),
	}
	return w
}

func (w *Window) String() string {
	return fmt.Sprintf("Window(%s)", w.id)
}

func (w *Window) Property(key string) (vit.Value, bool) {
	switch key {
	case "title":
		return &w.title, true
	case "maxWidth":
		return &w.maxWidth, true
	case "maxHeight":
		return &w.maxHeight, true
	case "minWidth":
		return &w.minWidth, true
	case "minHeight":
		return &w.minHeight, true
	default:
		return w.Item.Property(key)
	}
}

func (w *Window) MustProperty(key string) vit.Value {
	v, ok := w.Property(key)
	if !ok {
		panic(fmt.Errorf("MustProperty called with unknown key %q", key))
	}
	return v
}

func (w *Window) SetProperty(key string, value interface{}) error {
	var err error
	switch key {
	case "title":
		err = w.title.SetValue(value)
	case "maxWidth":
		err = w.maxWidth.SetValue(value)
	case "maxHeight":
		err = w.maxHeight.SetValue(value)
	case "minWidth":
		err = w.minWidth.SetValue(value)
	case "minHeight":
		err = w.minHeight.SetValue(value)
	default:
		return w.Item.SetProperty(key, value)
	}
	if err != nil {
		return vit.NewPropertyError("Window", key, w.id, err)
	}
	return nil
}

func (w *Window) SetPropertyExpression(key string, code string, pos *vit.PositionRange) error {
	switch key {
	case "title":
		w.title.SetExpression(code, pos)
	case "maxWidth":
		w.maxWidth.SetExpression(code, pos)
	case "maxHeight":
		w.maxHeight.SetExpression(code, pos)
	case "minWidth":
		w.minWidth.SetExpression(code, pos)
	case "minHeight":
		w.minHeight.SetExpression(code, pos)
	default:
		return w.Item.SetPropertyExpression(key, code, pos)
	}
	return nil
}

func (w *Window) ResolveVariable(key string) (interface{}, bool) {
	switch key {
	case w.id:
		return w, true
	case "title":
		return &w.title, true
	case "maxWidth":
		return &w.maxWidth, true
	case "maxHeight":
		return &w.maxHeight, true
	case "minWidth":
		return &w.minWidth, true
	case "minHeight":
		return &w.minHeight, true
	default:
		return w.Item.ResolveVariable(key)
	}
}

func (w *Window) AddChild(child vit.Component) {
	child.SetParent(w)
	w.AddChildButKeepParent(child)
}

func (w *Window) AddChildAfter(afterThis vit.Component, addThis vit.Component) {
	var targetType vit.Component = afterThis

	for ind, child := range w.Children() {
		if child.As(&targetType) {
			addThis.SetParent(w)
			w.AddChildAtButKeepParent(addThis, ind+1)
			return
		}
	}
	w.AddChild(addThis)
}

func (w *Window) UpdateExpressions() (int, vit.ErrorGroup) {
	var sum int
	var errs vit.ErrorGroup

	if changed, err := w.title.Update(w); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Window", "title", w.id, err))
		}
	}
	if changed, err := w.maxWidth.Update(w); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Window", "maxWidth", w.id, err))
		}
	}
	if changed, err := w.maxHeight.Update(w); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Window", "maxHeight", w.id, err))
		}
	}
	if changed, err := w.minWidth.Update(w); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Window", "minWidth", w.id, err))
		}
	}
	if changed, err := w.minHeight.Update(w); changed || err != nil {
		sum++
		if err != nil {
			errs.Add(vit.NewPropertyError("Window", "minHeight", w.id, err))
		}
	}

	// this needs to be done in every component and not just in root to give the expression the highest level component for resolving variables
	n, err := w.UpdatePropertiesInContext(w)
	sum += n
	errs.AddGroup(err)
	n, err = w.Item.UpdateExpressions()
	sum += n
	errs.AddGroup(err)
	return sum, errs
}

func (w *Window) As(target *vit.Component) bool {
	if _, ok := (*target).(*Window); ok {
		*target = w
		return true
	}
	return w.Item.As(target)
}

func (w *Window) ID() string {
	return w.id
}

func (w *Window) Finish() error {
	return w.RootC().FinishInContext(w)
}
